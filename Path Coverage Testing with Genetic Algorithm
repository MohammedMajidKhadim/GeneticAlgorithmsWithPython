#include <iostream>
#include<bits/stdc++.h>
#include <string>
#include <stdlib.h>
#include <cstring>
#include <cstdlib>
using namespace std;
int v_start=1;
int v_end=10;
const int size=5;
int test_data_x[size];
int test_data_y[size];
int test_data_z[size];
string binary_x[100];
string binary_y[100];
string binary_Z[100];
int mut[5];
int initial_population(int v_start, int v_end)
{
    for(int i=1;i<=10;i++)
    {        static bool v_start = false;
             if (!v_start) {
                   srand(time(NULL));
                   v_start = true;
                 }
             int range = (v_end-v_start)+1;
             int random_int = v_start+(rand()%range);
             test_data_x[i]=random_int;
             random_int = v_start+(rand()%range);
             test_data_y[i]=random_int;
             random_int = v_start+(rand()%range);
             test_data_z[i]=random_int;

     }
}

int Check_Coverage(int a, int b, int c)
  {
  int  t;
   int flag1=0;
   int flag2=0;
   int flag3=0;
   int flag4=0;
   int flag5=0;
       if(a>b)
            {if(b>c)
                { t=a;
               //      cout<<"The greatest number is "<<t<<endl;
                     flag1=1;


                  }
              else if(a>c)
                  {    t=a;
                //       cout<<"The greatest number is " <<t<<endl;
                       flag2=1;

                   }
                else
                {      t=c;
                   //     cout<<" The greatest number is "<<t<<endl;
                        flag3=1;

                  }
            }// first if
           else if(b>c)
                {t=b;
               //    cout<<" The greatest number is "<<t<<endl;
                   flag4=1;

                   }
              else
                   { t=c;
               //       cout<<" The greatest number is "<<t<<endl;
                      flag5=1;

                      }

              if (flag1==1 and flag2==0 and flag3==0 and flag4==0 and flag5==0)
                      return 1;
              else if(flag1==0 and flag2==1 and flag3==0 and flag4==0 and flag5==0)
                       return 2;
              else if(flag1==0 and flag2==0 and flag3==1 and flag4==0 and flag5==0)
                       return 3;
              else if(flag1==0 and flag2==0 and flag3==0 and flag4==1 and flag5==0)
                       return 4;
              else if(flag1==0 and flag2==0 and flag3==0 and flag4==0 and flag5==1)
                       return 5;
              else return 0;
}



string toBinary(int n)
{
    string str;
    string r;
    while (n != 0){
        r += ( n % 2 == 0 ? "0" : "1" );
        n /= 2;
    }
    reverse(r.begin(), r.end());
    int length = r.length();
    if (8-length>0)
    {
        str=str.append(8-length,'0');
        r=str.append(r);

    }
    return r;
}

int toDecimal(long binary)
{

   int decimalNum, i, rem;

   decimalNum = 0;
   i = 0;

   //converting binary to decimal
   while (binary != 0)
   {
      rem = binary % 10;
      binary /= 10;
      decimalNum += rem * pow(2, i);
      ++i;
   }

   return decimalNum;

}


void crossover(int f, int m, int l, string & x, string & y , string & z)
{




    float r = ((double) rand() / (RAND_MAX));  // find random number between 0 and 1


    if (r<=0.8) // 0.8 is the probability of crossover
          {

             int pos=0;
              x= toBinary(f);
              y= toBinary(m);
              z= toBinary(l);
              string temp;

                 pos = rand()% 8 + 1;   // random number between 1 and 8


                 temp=z;
                 x.replace(pos,3,(x.substr(pos,3)));
                 y.replace(pos,3,(temp.substr(pos,3)));


                        pos = rand()% 8 + 1;   // random number between 1 and 8

                      temp=y;
                      y.replace(pos,3,(z.substr(pos,3)));
                      z.replace(pos,3,(temp.substr(pos,3)));

              r=0;
            }

          }
void mutation(int f, int m, int l, string & x, string & y , string & z)
{


    float r = ((double) rand() / (RAND_MAX));  // find random number between 0 and 1




             int pos=0;
              x= toBinary(f);
              y= toBinary(m);
              z= toBinary(l);


                 pos = rand()% 8 + 1;   // random number between 1 and 8


                if (x.substr(pos,1)=="0")
                      x.replace(pos,1,"1");
                else if (x.substr(pos,1)=="1")
                       x.replace(pos,1,"0");
                 pos = rand()% 8 + 1;   // random number between 1 and 8

                   if (y.substr(pos,1)=="0")
                       y.replace(pos,1,"1");
                 else if (y.substr(pos,1)=="1")
                         y.replace(pos,1,"0");
                 pos = rand()% 8 + 1;   // random number between 1 and 8
                 if (z.substr(pos,1)=="0")
                     z.replace(pos,1,"1");
                  else if (y.substr(pos,1)=="1")
                         z.replace(pos,1,"0");




         pos=0;

}


int main()
{
    int path1=0;
    int path2=0;
    int path3=0;
    int path4=0;
    int path5=0;
    string  x;
    string y;
    string z;
    int xb;
    int yb;
    int zb;
    float pathcount=0;
    initial_population(v_start,v_end);
    cout<<" The initial population is : ";
    cout<<endl;
    for(int i=1; i<=5;i++)  // Printing the initial population
       {

               cout<<"["<<test_data_x[i]<<"]"<<" ";
               cout<<"["<<test_data_y[i]<<"]"<<" ";
               cout<<"["<<test_data_z[i]<<"]"<<" ";
               cout<<endl;
               cout<<toBinary(test_data_x[i])<<" ";
               cout<<toBinary(test_data_y[i])<<" ";
               cout<<toBinary(test_data_z[i])<<" ";
               cout<<endl;

       }
//------------------------------------------------------------------Check the initial population Coverage
     for(int i=1; i<=5;i++)
        {
               cout<<endl;
               int coveredpath=Check_Coverage(test_data_x[i], test_data_y[i], test_data_z[i]);
                cout<<coveredpath<<endl;
               if (coveredpath==1)
                        path1=1;
               else if (coveredpath==2)
                        path2=1;
               else if (coveredpath==3)
                        path3=1;
               else if (coveredpath==4)
                        path4=1;
               else if (coveredpath==5)
                        path5=1;
       }
      pathcount=path1+path2+path3+path4+path5;
       cout<<endl;
      cout<<"coverage rate= "<<((pathcount/5)*100)<<"%"<<endl;
      cout<<"_______________________________________________________________"<<endl;
      int iter=0;
      int flag;
      int loopc=0;
   while (pathcount!=5)
     {    srand(time(NULL));
          path1=0;
          path2=0;
          path3=0;
          path4=0;
          path5=0;
          int g=1;
          iter+=1;
          cout<<"Iteration "<<iter<<endl;
          cout<<"_________________"<<endl;


          for(int i=1; i<=5;i++) //--------------------------------perform crossover / in the same generation
                {  int  coveredpath;
                    flag=1;
                   cout<<"After Crossover ::"<<endl;
                   crossover(test_data_x[i],test_data_y[i],test_data_z[i], x, y, z);
                   test_data_x[i]=toDecimal(stol(x));
                   test_data_y[i]=toDecimal(stol(y));
                   test_data_z[i]=toDecimal(stol(z));
                    xb=test_data_x[i];
                    yb=test_data_y[i];
                    zb=test_data_z[i];
                   cout<<"["<<test_data_x[i]<<"]"<<" ";
                   cout<<"["<<test_data_y[i]<<"]"<<" ";
                   cout<<"["<<test_data_z[i]<<"]"<<" ";
                   cout<<endl<<endl;
                   float r = ((double) rand() / (RAND_MAX));  // find random number between 0 and 1
                   if (r<=0.6 )// 0.6 is the probability of mutation
                   {
                   cout<<"After Mutation ::"<<endl;
                    mutation(test_data_x[i],test_data_y[i],test_data_z[i], x, y, z);
                    test_data_x[i]=toDecimal(stol(x));
                    test_data_y[i]=toDecimal(stol(y));
                    test_data_z[i]=toDecimal(stol(z));
                    cout<<"["<<test_data_x[i]<<"]"<<" ";
                    cout<<"["<<test_data_y[i]<<"]"<<" ";
                    cout<<"["<<test_data_z[i]<<"]"<<" ";
                    cout<<endl;

                    int  coveredpath=Check_Coverage(test_data_x[i], test_data_y[i], test_data_z[i]);



               while (flag==1)  //--------------------multi mutation (our enhanced mutation technique)
               { loopc++;
                  for (int j=1;j<=5;j++)
                  {
                   //  cout<<"MUT[]"<<j<<": "<<mut[j]<<endl;
                       if (mut[j]==coveredpath)
                          {
                             flag=2;
                             cout<<endl;
                             cout<<"duplicated path "<<coveredpath<<endl;
                             cout<<endl;
                   cout<<"[["<<test_data_x[i]<<"]"<<" ";
                   cout<<"["<<test_data_y[i]<<"]"<<" ";
                   cout<<"["<<test_data_z[i]<<"]"<<" ";
                   cout<<endl;

                          }

                   }

                if (flag==2)
                {

                    mutation(xb,yb,zb, x, y, z);
                    test_data_x[i]=toDecimal(stol(x));
                    test_data_y[i]=toDecimal(stol(y));
                    test_data_z[i]=toDecimal(stol(z));
                    coveredpath=Check_Coverage(test_data_x[i], test_data_y[i], test_data_z[i]);
                     flag=1;

                  }
                else if (flag==1)
                    {
                        flag=0;

                          mut[g]=coveredpath;
                          cout<<"coveredpath="<<coveredpath<<endl;
                         // cout<<"mut="<<mut[g]<<endl;
                          g+=1;



                       }
                       if (loopc>100)
                       {
                           loopc=0;
                           flag=0;
                       }

                   }

                   }


                   cout<<endl;
                   cout<<"["<<test_data_x[i]<<"]"<<" ";
                   cout<<"["<<test_data_y[i]<<"]"<<" ";
                   cout<<"["<<test_data_z[i]<<"]"<<" ";
                   cout<<endl;
                   coveredpath=0;
                   coveredpath=Check_Coverage(test_data_x[i], test_data_y[i], test_data_z[i]);
                    cout<<"The covered Target Path is :";
                    cout<<Check_Coverage(test_data_x[i], test_data_y[i], test_data_z[i])<<endl;
               if (coveredpath==1)
                        path1=1;
               else if (coveredpath==2)
                        path2=1;
               else if (coveredpath==3)
                        path3=1;
               else if (coveredpath==4)
                        path4=1;
               else if (coveredpath==5)
                        path5=1;



                 }
                g=1;
                  pathcount=path1+path2+path3+path4+path5;
                  cout<<endl;
                  srand(time(NULL));
                  cout<<"Path coverage rate= "<<((pathcount/5)*100)<<"%"<<endl;
                  cout<<endl;
                  cout<<"The number of test data iterations is "<<iter<<endl;
                  cout<<"_______________________________________________________________"<<endl;
         }

      cout<<"the fittest test data for path coverage testing is "<<endl;
            for(int i=1; i<=5;i++)
               {
                   cout<<"["<<test_data_x[i]<<"]"<<" ";
                   cout<<"["<<test_data_y[i]<<"]"<<" ,";
                   cout<<"["<<test_data_z[i]<<"]"<<" ,";
                   cout<<endl;

                }



}

